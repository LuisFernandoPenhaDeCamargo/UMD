!function(t,o){"object"==typeof exports&&"undefined"!=typeof module?module.exports=o(require("three")):"function"==typeof define&&define.amd?define(["three"],o):(t="undefined"!=typeof globalThis?globalThis:t||self).ThreeCSG=o(t.THREE)}(this,function(t){"use strict";class o{constructor(t){this.top=0,this.array=new Float32Array(t)}write(t){this.array[this.top++]=t.x,this.array[this.top++]=t.y,this.array[this.top++]=t.z}}class e{constructor(t){this.top=0,this.array=new Float32Array(t)}write(t){this.array[this.top++]=t.x,this.array[this.top++]=t.y}}class s{constructor(t){this.plane=null,this.front=null,this.back=null,this.polygons=[],t&&this.build(t)}clone(){const t=new s;return t.plane=this.plane&&this.plane.clone(),t.front=this.front&&this.front.clone(),t.back=this.back&&this.back.clone(),t.polygons=this.polygons.map(t=>t.clone()),t}invert(){for(let t=0;t<this.polygons.length;t++)this.polygons[t].flip();this.plane&&this.plane.flip(),this.front&&this.front.invert(),this.back&&this.back.invert();const t=this.front;this.front=this.back,this.back=t}clipPolygons(t){if(!this.plane)return t.slice();let o=new Array,e=new Array;for(let s=0;s<t.length;s++)this.plane.splitPolygon(t[s],o,e,o,e);return this.front&&(o=this.front.clipPolygons(o)),e=this.back?this.back.clipPolygons(e):[],o.concat(e)}clipTo(t){this.polygons=t.clipPolygons(this.polygons),this.front&&this.front.clipTo(t),this.back&&this.back.clipTo(t)}allPolygons(){let t=this.polygons.slice();return this.front&&(t=t.concat(this.front.allPolygons())),this.back&&(t=t.concat(this.back.allPolygons())),t}build(t){if(!t.length)return;this.plane||(this.plane=t[0].plane.clone());const o=[],e=[];for(let s=0;s<t.length;s++)this.plane.splitPolygon(t[s],this.polygons,this.polygons,o,e);o.length&&(this.front||(this.front=new s),this.front.build(o)),e.length&&(this.back||(this.back=new s),this.back.build(e))}}class r{constructor(t=0,o=0,e=0){this.x=t,this.y=o,this.z=e}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}clone(){return new r(this.x,this.y,this.z)}negate(){return this.x*=-1,this.y*=-1,this.z*=-1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}times(t){return this.x*=t,this.y*=t,this.z*=t,this}dividedBy(t){return this.x/=t,this.y/=t,this.z/=t,this}lerp(t,o){return this.add((new r).copy(t).sub(this).times(o))}unit(){return this.dividedBy(this.length())}length(){return Math.sqrt(Math.pow(this.x,2)+Math.pow(this.y,2)+Math.pow(this.z,2))}normalize(){return this.unit()}cross(t){const o=this.clone(),e=o.x,s=o.y,r=o.z,n=t.x,i=t.y,l=t.z;return this.x=s*l-r*i,this.y=r*n-e*l,this.z=e*i-s*n,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}toVector3(){return new t.Vector3(this.x,this.y,this.z)}}class n{constructor(t,o){this.normal=t,this.w=o,this.normal=t,this.w=o}clone(){return new n(this.normal.clone(),this.w)}flip(){this.normal.negate(),this.w=-this.w}splitPolygon(t,o,e,s,l){let h=0;const a=[];for(let o=0;o<t.vertices.length;o++){const e=this.normal.dot(t.vertices[o].pos)-this.w,s=e<-n.EPSILON?2:e>n.EPSILON?1:0;h|=s,a.push(s)}switch(h){case 0:(this.normal.dot(t.plane.normal)>0?o:e).push(t);break;case 1:s.push(t);break;case 2:l.push(t);break;case 3:{const o=[],e=[];for(let s=0;s<t.vertices.length;s++){const n=(s+1)%t.vertices.length,i=a[s],l=a[n],h=t.vertices[s],c=t.vertices[n];if(2!=i&&o.push(h),1!=i&&e.push(2!=i?h.clone():h),3==(i|l)){const t=(this.w-this.normal.dot(h.pos))/this.normal.dot((new r).copy(c.pos).sub(h.pos)),s=h.interpolate(c,t);o.push(s),e.push(s.clone())}}o.length>=3&&s.push(new i(o,t.shared)),e.length>=3&&l.push(new i(e,t.shared));break}}}static fromPoints(t,o,e){const s=(new r).copy(o).sub(t).cross((new r).copy(e).sub(t)).normalize();return new n(s.clone(),s.dot(t))}}n.EPSILON=1e-5;class i{constructor(t,o){this.vertices=t,this.shared=o,this.plane=n.fromPoints(t[0].pos,t[1].pos,t[2].pos)}clone(){return new i(this.vertices.map(t=>t.clone()),this.shared)}flip(){this.vertices.reverse().map(t=>t.flip()),this.plane.flip()}}class l{constructor(t,o,e,s){this.pos=(new r).copy(t),this.normal=(new r).copy(o),this.uv=(new r).copy(e),this.uv.z=0,s&&(this.color=(new r).copy(s))}clone(){return new l(this.pos,this.normal,this.uv,this.color)}flip(){this.normal.negate()}interpolate(t,o){return new l(this.pos.clone().lerp(t.pos,o),this.normal.clone().lerp(t.normal,o),this.uv.clone().lerp(t.uv,o),this.color&&t.color&&this.color.clone().lerp(t.color,o))}}class h{constructor(){this.polygons=[]}static fromPolygons(t){const o=new h;return o.polygons=t,o}static fromGeometry(t,o){let e=[];const s=t.attributes.position,n=t.attributes.normal,a=t.attributes.uv,c=t.attributes.color,p=t.groups;let u;if(t.index)u=t.index.array;else{u=new Uint16Array(s.array.length/s.itemSize|0);for(let t=0;t<u.length;t++)u[t]=t}const y=u.length/3|0;e=new Array(y);for(let t=0,h=0,y=u.length;t<y;t+=3,h++){const y=new Array(3);for(let o=0;o<3;o++){const e=u[t+o],i=3*e,h=2*e,p=s.array[i],f=s.array[i+1],g=s.array[i+2],w=n.array[i],m=n.array[i+1],d=n.array[i+2],b=null==a?void 0:a.array[h],v=null==a?void 0:a.array[h+1];y[o]=new l(new r(p,f,g),new r(w,m,d),new r(b,v,0),c&&new r(c.array[i],c.array[i+1],c.array[i+2]))}if(void 0===o&&p&&p.length>0)for(const o of p)t>=o.start&&t<o.start+o.count&&(e[h]=new i(y,o.materialIndex));else e[h]=new i(y,o)}return h.fromPolygons(e.filter(t=>!Number.isNaN(t.plane.normal.x)))}static toGeometry(s,r){let n=0;const i=s.polygons;for(const t of i)n+=t.vertices.length-2;const l=new t.BufferGeometry,h=new o(3*n*3),a=new o(3*n*3),c=new e(2*n*3);let p;const u=[],y=[];for(const t of i){const e=t.vertices,s=e.length;void 0!==t.shared&&(u[t.shared]||(u[t.shared]=[])),s&&void 0!==e[0].color&&(p||(p=new o(3*n*3)));for(let o=3;o<=s;o++){(void 0===t.shared?y:u[t.shared]).push(h.top/3,h.top/3+1,h.top/3+2),h.write(e[0].pos),h.write(e[o-2].pos),h.write(e[o-1].pos),a.write(e[0].normal),a.write(e[o-2].normal),a.write(e[o-1].normal),c&&(c.write(e[0].uv),c.write(e[o-2].uv),c.write(e[o-1].uv)),p&&(p.write(e[0].color),p.write(e[o-2].color),p.write(e[o-1].color))}}l.setAttribute("position",new t.BufferAttribute(h.array,3)),l.setAttribute("normal",new t.BufferAttribute(a.array,3)),c&&l.setAttribute("uv",new t.BufferAttribute(c.array,2)),p&&l.setAttribute("color",new t.BufferAttribute(p.array,3));for(let t=0;t<u.length;t++)void 0===u[t]&&(u[t]=[]);if(u.length){let t=[],o=0;for(let e=0;e<u.length;e++)l.addGroup(o,u[e].length,e),o+=u[e].length,t=t.concat(u[e]);l.addGroup(o,y.length,u.length),t=t.concat(y),l.setIndex(t)}const f=(new t.Matrix4).copy(r).invert();return l.applyMatrix4(f),l.computeBoundingSphere(),l.computeBoundingBox(),l}static fromMesh(o,e){const s=h.fromGeometry(o.geometry,e),r=new t.Vector3,n=new t.Matrix3;n.getNormalMatrix(o.matrix);for(let t=0;t<s.polygons.length;t++){const e=s.polygons[t];for(let t=0;t<e.vertices.length;t++){const s=e.vertices[t];s.pos.copy(r.copy(s.pos.toVector3()).applyMatrix4(o.matrix)),s.normal.copy(r.copy(s.normal.toVector3()).applyMatrix3(n))}}return s}static toMesh(o,e,s){const r=h.toGeometry(o,e),n=new t.Mesh(r,s);return n.matrix.copy(e),n.matrix.decompose(n.position,n.quaternion,n.scale),n.rotation.setFromQuaternion(n.quaternion),n.updateMatrixWorld(),n.castShadow=n.receiveShadow=!0,n}static union(t,o){const e=h.fromMesh(t),s=h.fromMesh(o);return h.toMesh(e.union(s),t.matrix,t.material)}static subtract(t,o){const e=h.fromMesh(t),s=h.fromMesh(o);return h.toMesh(e.subtract(s),t.matrix,t.material)}static intersect(t,o){const e=h.fromMesh(t),s=h.fromMesh(o);return h.toMesh(e.intersect(s),t.matrix,t.material)}clone(){const t=new h;return t.polygons=this.polygons.map(t=>t.clone()).filter(t=>Number.isFinite(t.plane.w)),t}toPolygons(){return this.polygons}union(t){const o=new s(this.clone().polygons),e=new s(t.clone().polygons);return o.clipTo(e),e.clipTo(o),e.invert(),e.clipTo(o),e.invert(),o.build(e.allPolygons()),h.fromPolygons(o.allPolygons())}subtract(t){const o=new s(this.clone().polygons),e=new s(t.clone().polygons);return o.invert(),o.clipTo(e),e.clipTo(o),e.invert(),e.clipTo(o),e.invert(),o.build(e.allPolygons()),o.invert(),h.fromPolygons(o.allPolygons())}intersect(t){const o=new s(this.clone().polygons),e=new s(t.clone().polygons);return o.invert(),e.clipTo(o),e.invert(),o.clipTo(e),e.clipTo(o),o.build(e.allPolygons()),o.invert(),h.fromPolygons(o.allPolygons())}inverse(){const t=this.clone();for(const o of t.polygons)o.flip();return t}toMesh(t,o){return h.toMesh(this,t,o)}toGeometry(t){return h.toGeometry(this,t)}}return Object.freeze({__proto__:null,CSG:h})});
